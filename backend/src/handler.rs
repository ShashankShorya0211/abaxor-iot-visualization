// src/handler.rs
//! HTTP handlers for interacting with the FPGA stream + registers.
//!
//! - reg_bank::init() / reg_fifo::init() to open devices
//! - fifo_stream::{init_fifo, start_streaming, start_streaming_without_offset,
//!   start_ramp_gen, stop_streaming, stop_ramp_gen, decode_datablock}
//!
//! It intentionally **does not** expose generic "read/write by offset" register
//! endpoints because your autogenerated `reg_bank.rs` doesn't provide generic
//! `read_register/write_register` functions.
//!
//! Endpoints:
//!   GET  /api/health
//!   POST /api/stream/start?mode=with_offset|without_offset|ramp
//!   POST /api/stream/stop
//!   GET  /api/stream/once?packets=1&mode=with_offset|without_offset|ramp
//!
//! Notes:
//! - We open the device FDs inside each handler (simple & robust).
//! - For one-shot reads we call `init_fifo` once to ensure clean state.

use actix_web::{get, post, web, HttpResponse, Responder};
use serde::{Deserialize, Serialize};
use std::os::unix::prelude::RawFd;

use crate::{fifo_stream, flags, reg_bank, reg_fifo};

/// Query params for /api/stream/start and /api/stream/once
#[derive(Debug, Deserialize)]
pub struct ModeQuery {
    /// "with_offset" (default), "without_offset", or "ramp"
    pub mode: Option<String>,
}

#[derive(Debug, Deserialize)]
pub struct OnceQuery {
    /// number of 256-word packets to read (default 1)
    pub packets: Option<u32>,
    /// "with_offset" (default), "without_offset", or "ramp"
    pub mode: Option<String>,
}

/// Response for /api/health
#[derive(Debug, Serialize)]
struct HealthResp {
    fifo_device_present: bool,
    status: &'static str,
}

/// JSON we return for a decoded one-shot block
#[derive(Debug, Serialize)]
struct DecodedResp {
    glitches: usize,
    /// Per-channel samples (each channel is Vec<i16>); the last slot is MeasNr stream.
    channel_data: Vec<Vec<i16>>,
    /// Number of raw 32-bit words captured (headers + data) — useful for debugging
    raw_words_len: usize,
}

/// Map `mode` string to streaming selection + decode option.
fn mode_to_actions(mode: Option<String>) -> (&'static str, u8) {
    match mode
        .as_deref()
        .map(|m| m.trim().to_ascii_lowercase())
        .as_deref()
    {
        Some("without_offset") => ("without_offset", flags::STREAM_WITHOUT_OFFSET),
        Some("ramp") => ("ramp", flags::STREAM_WITH_RAMP),
        _ => ("with_offset", flags::STREAM_WITH_OFFSET),
    }
}

/// Open devices (reg + fifo). Small helper so we keep handlers tidy.
fn open_devices() -> Result<(RawFd, RawFd), HttpResponse> {
    // These functions exist in your codebase and return opened file descriptors.
    let reg_fd = reg_bank::init();
    let fifo_fd = reg_fifo::init();
    Ok((reg_fd, fifo_fd))
}

#[get("/api/health")]
pub async fn health() -> impl Responder {
    let present = fifo_stream::exists_fifo_module();
    let body = HealthResp {
        fifo_device_present: present,
        status: if present { "ok" } else { "fifo_device_missing" },
    };
    HttpResponse::Ok().json(body)
}

#[post("/api/stream/start")]
pub async fn start_stream(query: web::Query<ModeQuery>) -> impl Responder {
    let (mode_str, _opt_flag) = mode_to_actions(query.mode.clone());

    let (reg_fd, fifo_fd) = match open_devices() {
        Ok(fds) => fds,
        Err(e) => return e,
    };

    // Warm-up/clean FIFO (no CSV, just internal checks)
    fifo_stream::init_fifo(fifo_fd, reg_fd);

    // Start according to mode
    match mode_str {
        "without_offset" => fifo_stream::start_streaming_without_offset(reg_fd),
        "ramp" => fifo_stream::start_ramp_gen(reg_fd),
        _ => fifo_stream::start_streaming(reg_fd), // with_offset (default)
    }

    HttpResponse::Ok().json(serde_json::json!({
        "status": "started",
        "mode": mode_str,
    }))
}

#[post("/api/stream/stop")]
pub async fn stop_stream() -> impl Responder {
    let (reg_fd, fifo_fd) = match open_devices() {
        Ok(fds) => fds,
        Err(e) => return e,
    };

    // Stop both transfer and ramp (safe to call regardless of current state)
    fifo_stream::stop_streaming(reg_fd);
    fifo_stream::stop_ramp_gen(reg_fd);

    // Clear FIFO so a next start begins clean
    fifo_stream::clear_fifo(fifo_fd);

    HttpResponse::Ok().json(serde_json::json!({
        "status": "stopped"
    }))
}

#[get("/api/stream/once")]
pub async fn stream_once(query: web::Query<OnceQuery>) -> impl Responder {
    let packets = query.packets.unwrap_or(1).max(1);
    let (mode_str, opt_flag) = mode_to_actions(query.mode.clone());

    let (reg_fd, fifo_fd) = match open_devices() {
        Ok(fds) => fds,
        Err(e) => return e,
    };

    // Make sure FIFO is in a sane state
    fifo_stream::init_fifo(fifo_fd, reg_fd);

    // For a single read, we don't need to leave streaming enabled; we just decode whatever arrives.
    // If you want to ensure data, you can momentarily enable transfer depending on mode:
    match mode_str {
        "without_offset" => fifo_stream::start_streaming_without_offset(reg_fd),
        "ramp" => fifo_stream::start_ramp_gen(reg_fd),
        _ => fifo_stream::start_streaming(reg_fd),
    }

    // Decode N packets with the chosen option
    let decoded = fifo_stream::decode_datablock(fifo_fd, packets, opt_flag);

    // Stop again (don’t leave the board streaming after a one-shot)
    fifo_stream::stop_streaming(reg_fd);
    fifo_stream::stop_ramp_gen(reg_fd);

    // Convert fixed-size array to Vec for JSON
    let channel_vec: Vec<Vec<i16>> = decoded.channel_data.into_iter().collect();

    let resp = DecodedResp {
        glitches: decoded.glitches,
        channel_data: channel_vec,
        raw_words_len: decoded.raw_words.len(),
    };

    HttpResponse::Ok().json(resp)
}

/// Wire routes into the Actix app (called from main.rs)
pub fn config(cfg: &mut web::ServiceConfig) {
    cfg.service(health)
        .service(start_stream)
        .service(stop_stream)
        .service(stream_once);
}

